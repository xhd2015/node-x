!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var t=n();for(var o in t)("object"==typeof exports?exports:e)[o]=t[o]}}(globalThis,(()=>(()=>{"use strict";var e={258:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.formatWebpackConfigJS=n.formatTsConfigJSON=n.formatPackageJSON=void 0,n.formatPackageJSON=function(e){const n=e?.installMap||{},t={"@babel/cli":"^7.1.0","@babel/core":"^7.1.0","@babel/preset-env":"^7.1.0","babel-loader":"^8.1.0","file-loader":"^6.0.0","ts-loader":"^9.3.1","webpack-cli":"^4.10.0","@types/node":"^18.15.11"};Object.keys(n||{}).forEach((e=>{t[`@types/${e}`]="latest"}));const o={name:`${e?.name||"tmp"}`,version:"0.0.1",scripts:{build:"node ./node_modules/.bin/webpack --config webpack.config.js --progress --mode=production","build-dev":"node ./node_modules/.bin/webpack --config webpack.config.js --progress --mode=development","watch-dev":"node ./node_modules/.bin/webpack --watch --config webpack.config.js --progress --mode=development",start:"npm install && npm run build && node bin/run.js"},dependencies:n,devDependencies:t};return JSON.stringify(o,null,"    ")},n.formatTsConfigJSON=function(e){const n={};return Object.keys(e?.importMap||{}).forEach((t=>{let o=e.importMap[t];o.endsWith("/")||(o+="/"),n[t+"/*"]=[o+"*"]})),`{\n        // Change this to match your project\n        // "include": [],\n        "compilerOptions": {\n            // Tells TypeScript to read JS files, as\n            // normally they are ignored as source files\n            // "allowJs": true,\n            // Generate d.ts files\n            // "declaration": true,\n            // This compiler run should\n            // only output d.ts files\n            // "emitDeclarationOnly": true,\n            // Types should go into this directory.\n            // Removing this would place the .d.ts files\n            // next to the .js files\n            //   "outDir": "dist"\n            "target": "ES2021",\n            "lib": [\n                "ES2021",\n                "ES2021.String"\n            ],\n            // "target": "es6",\n            "module": "commonjs",\n            // "module": "ES2015",\n            // "outDir": "src/debug",\n            "moduleResolution": "node",\n            "rootDirs": ["./"],\n            "paths": ${JSON.stringify(n)}\n        },\n        "exclude": []\n    }`},n.formatWebpackConfigJS=function(e){const n=[];return Object.keys(e?.importMap||{}).forEach((t=>{let o=e.importMap[t].trim();n.push(`"${t}": path.resolve(__dirname,"${o}")`)})),`const path = require("path");\n    \n    module.exports = {\n      entry: {\n        run: {\n          import: "./run.ts",\n          filename: "run.js",\n        },\n      },\n      output: {\n        path: path.resolve(__dirname, "bin"),\n        libraryTarget: "umd", // for nodejs need this\n        globalObject: "globalThis", // goja only recognize globalThis, not the default global.\n      },\n      module: {\n        rules: [\n          {\n            test: /.ts$/,\n            // exclude: /(node_modules)/,\n            use: {\n              loader: "ts-loader",\n              options: {\n                transpileOnly: true,\n              },\n            },\n          },\n          {\n            test: /.(js)$/,\n            exclude: /(node_modules)/,\n            resolve: {\n              extensions: [".ts", ".js"],\n            },\n            use: {\n              loader: "babel-loader",\n              options: {\n                presets: ["@babel/preset-env"],\n              },\n            },\n          },\n        ],\n      },\n      resolve: {\n        alias: ${"{"+n.join(",\n")+"}"},\n        extensions: [".ts", ".js"],\n      },\n      target: "node",\n      node:{\n        __filename:true,\n        __dirname:true,  // these two options make the __filename & __dirname correspond to original file name\n      },\n      plugins: [],\n      // devtool: "source-map",\n    };\n    `}},900:(e,n,t)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.runCmd=n.parseOptions=n.runOutput=n.catchedRun=n.run=void 0;const o=t(81),r=t(265);async function i(e,n){const t=o.spawn("bash",[`-e${n?.debug?"x":""}c`,e,"--",...n?.args||[]],{cwd:n?.cwd,env:{...process.env,...n?.env}});n?.pipeStdin&&process.stdin.pipe(t.stdin,{end:!0}),t.stderr.on("data",(e=>process.stderr.write(e)));let r="";return n?.needStdout?t.stdout.on("data",(e=>r+=e)):t.stdout.on("data",(e=>process.stdout.write(e))),new Promise(((o,i)=>{t.on("error",(function(e){i(e)})),t.on("close",(function(t){if(0!==t){let o=n?.description;const r=100;if(!o)if(e.length<=r)o=e;else{const n=e.split("\n").map((e=>e.trim())).join("\n");o=n.length<=r?n:n.slice(0,r)+"..."}i(new Error(`exit code ${t}: ${o}`))}else o({exitCode:t,stdout:r})}))}))}Object.defineProperty(n,"parseOptions",{enumerable:!0,get:function(){return r.parse}}),n.run=i,n.runCmd=i,n.catchedRun=async function(e){e().catch((e=>{console.error(e?.message||e),process.exit(1)}))},n.runOutput=async function(e,n){return i(e,{...n,needStdout:!0}).then((e=>e.stdout.endsWith("\n")?e.stdout.slice(0,e.stdout.length-1):e.stdout))}},265:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.parse=void 0,n.parse=function(e,n,t,o){t&&(o||Array.isArray(t)||(t=(o=t)?.argv)),null==t&&(t=process.argv.slice(2));const r=t,i=n.split(/\s+/),s={},a={},l={},c=o?.stopAtFirstArg;for(let e of i){let n,t=e.lastIndexOf("=");-1!=t&&(n=e.slice(t+1),e=e.slice(0,t));let o="zero";e.endsWith("::")?(o="many",e=e.slice(0,e.length-2)):e.endsWith(":")&&(o="one",e=e.slice(0,e.length-1));const r=e.split(",");if(0==r.length)continue;const i=r[r.length-1];if(null!=a[i])throw new Error(`duplicate option name:${i}`);a[i]=o,n&&(l[i]=n);for(const e of r)if(0!=e.length){if(null!=s[e])throw new Error(`duplicate option name:${e}`);s[e]=i}}const d=[],u={},p={};let f=0;function m(e,n){let o=n===p;o&&(n=null);const r=s[e];if(!r)throw new Error(`no such option:${e}`);const i=l[r];if(i&&(u[i]=e),"zero"===a[r]){if(o)return void(u[r]=!0);if(null!=n)if("on"==n||"On"==n||"ON"==n||"true"==n||"True"==n||"TRUE"==n)u[r]=!0;else{if("off"!=n&&"Off"!=n&&"OFF"!=n&&"false"!=n&&"False"!=n&&"FALSE"!=n)throw new Error(`option requires no argument:${e},except on/On/ON/true/True/TRUE or off/Off/OFF/false/False/FALSE`);u[r]=!1}else u[r]=!0}else if("one"===a[r]){if(o&&(n=t[++f]),null==n)throw new Error(`option requires one argument:${e}`);u[r]=n}else{if("many"!==a[r])throw new Error(`unknown option repeat:${e} ${a[r]}`);if(o&&(n=t[++f]),null==n)throw new Error(`option requires argument:${e}`);null==u[r]?u[r]=[n]:u[r].push(n)}}for(;f<r.length;f++){const e=t[f];if("--"==e){d.push(...r.slice(f+1));break}if("-"!=e)if(e.startsWith("--")){let n=e.slice(2);const t=n.lastIndexOf("=");let o;-1!=t?(o=n.slice(t+1),n=n.slice(0,t)):o=p,m(n,o)}else if(e.startsWith("-")){const n=e.slice(1);if(1==n.length){m(n,p);continue}const t=n[0],o=s[t],r=a[o];if("one"==r||"many"==r)m(t,n.slice(1));else if("zero"==r){for(const e of n.slice(0,n.length-1))m(e,null);m(n[n.length-1],p)}}else{if(c){d.push(...r.slice(f));break}d.push(e)}else d.push(e)}function h(){let n=e;return n.startsWith("\n")&&(n=n.slice(1)),n.endsWith("\n")&&(n=n.slice(0,n.length-1)),n}return!0===u.help&&(console.log(h()),process.exit(0)),{args:d,options:u,getHelp:h}}},65:(e,n)=>{function t(e,n,t){const o=[],r=e.length;for(let i=0;i<r;){let s=n(e,i);s<0&&(s=r),o.push(t(i,s,e)),i=s+1}return o}Object.defineProperty(n,"__esModule",{value:!0}),n.addSuffix=n.trimSuffix=n.trimPrefix=n.iterMatch=n.iterLines=void 0,n.iterLines=function(e,n){return t(e,((e,n)=>e.indexOf("\n",n)),n)},n.iterMatch=t,n.trimPrefix=function(e,n){return e?.startsWith?.(n)?[e.slice(n.length),!0]:[e,!1]},n.trimSuffix=function(e,n){return e?.endsWith?.(n)?[e.slice(0,e.length-n.length),!0]:[e,!1]},n.addSuffix=function(e,n){return e.endsWith(n)?e:e+n}},650:(e,n)=>{Object.defineProperty(n,"__esModule",{value:!0}),n.files=void 0,n.files={},n.files["cmd.ts"]='//#!node-ext: install moment\n\nimport { run as runCmd, parseOptions } from "@node-ext/cmd"\nimport { resolveShellPath } from "@node-ext/env"\nimport path = require("path")\nimport moment from \'moment\'\nimport { mkdir, readFile } from "fs/promises"\n\nconst help = `\nUsage: __CMD__ flush working\n       __CMD__ download working\n\nOptions:\n  -h, --help               help\n\nExamples:\n  $ \n`\n\nexport interface Options {\n}\n\nasync function run() {\n    // argv: [node, sync.js, ...]\n    const { args: [cmd, ...args], options } = parseOptions<Options>(help, "h,help", { stopAtFirstArg: true })\n    if (!cmd) {\n        throw new Error("requires cmd")\n    }\n    if (cmd === \'flush\') {\n        // do flush\n    } else {\n        throw new Error(`unknown cmd: ${cmd}`)\n    }\n}\n\nrun().catch(e => {\n    console.error(e.message)\n    process.exit(1)\n})',n.files["cmd-with-config.ts"]='//#!node-ext: install moment\n\nimport { run as runCmd, parseOptions } from "@node-ext/cmd"\nimport { resolveShellPath } from "@node-ext/env"\nimport path = require("path")\nimport dateFormat from \'dateformat\'\nimport { mkdir, readFile } from "fs/promises"\n\nconst help = `\nUsage: __CMD__ flush working\n       __CMD__ download working\n\nOptions:\n  -h, --help               help\n  -x, --debug              debug\n  -f, --force              force lock\n`\n\nexport interface Config {\n    use?: string\n}\n\nasync function init() {\n    const cfgJSON = await readFile(resolveShellPath("~/.nx-sync.json"), { \'encoding\': \'utf-8\' }).catch(() => { })\n\n    let cfg: Config\n    try {\n        cfg = cfgJSON ? JSON.parse(cfgJSON as string) : null\n    } catch (e) {\n\n    }\n\n    // create ~/.nx-sync/\n    await mkdir(resolveShellPath("~/.nx-sync"), { recursive: true })\n}\n\nexport interface Options {\n    help?: boolean\n    debug?: boolean\n}\n\nasync function run() {\n    await init()\n\n    // argv: [node, sync.js, ...]\n    const { args: [cmd, ...args], options } = parseOptions<Options>(help, "h,help x,debug f,force", { stopAtFirstArg: true })\n    const { debug, force, pause } = options\n    if (!cmd) {\n        throw new Error("requires cmd")\n    }\n    if (cmd === \'flush\') {\n        // do flush\n    } else {\n        throw new Error(`unknown cmd: ${cmd}`)\n    }\n}\n\nrun().catch(e => {\n    console.error(e.message)\n    process.exit(1)\n})'},81:e=>{e.exports=require("child_process")},113:e=>{e.exports=require("crypto")},292:e=>{e.exports=require("fs/promises")},37:e=>{e.exports=require("os")},17:e=>{e.exports=require("path")}},n={};function t(o){var r=n[o];if(void 0!==r)return r.exports;var i=n[o]={exports:{}};return e[o](i,i.exports,t),i.exports}var o={};return(()=>{var e=o;Object.defineProperty(e,"__esModule",{value:!0}),e.toDirName=e.run=void 0;const n=t(17),r=t(292),i=t(37),s=t(258),a=t(900),l=t(113),c=t(65),d=t(650);async function u(){const e=process.env.NX_FLAGS;let t=[...process.argv.slice(2)];e&&(t=[...e.split(" ").map((e=>e.trim())),...t]);const{args:o,options:c}=(0,a.parseOptions)("Usage: nx [OPTIONS] <script> [--] [script-args...]\n\nOptions:\n  -h, --help          show help message\n  -p, --print-dir     print the generated directory\n      --root          print root directory and exit\n  -x, --debug         log debug info\n  -c, --code          open the directory with vscode\n  -f, --force         force install modules\n      --clean         clean the target dir before writing files\n      --rm            remove the target dir and exit\n      --keep-link     don't resolve the script if it is a link\n      --install       install dependencies and exit, i.e. run `npm install` in target directory\n      --mode=production|development    default mode: development\n      --fast           skip npm install and webpack build, just run the script\n      --rebuild        run npm install and webpack build\n      --watch          start webpack --watch\n      \nOptions for create:\n      --template NAME  used with nx create,by default cmd.ts is used. If NAME is list,list all available names\n\nSubcommands:\n  update            update nx\n  create FILE.ts    create a typescript file with given template,if no FILE, output to stdout         \n\nOnce installed with `npm install -g node-ext`, `nx` will be automatically linked to /usr/local/bin so you can just use `nx` to run scripts\n\nExample:\n  $ nx --help           # show help\n  $ nx test.ts          # run test.ts\n  $ nx -x test.ts       # run test.ts, with debug info\n  $ nx --code test.ts   # open the directory\n  $ nx update           # update node-ext version\n  $ nx create\n\nCompare with `ts-node`: you can also use `ts-node` to run typescript, e.g. `npx -g ts-node --transpile-only test.ts`.\nThe advantage that `nx` provides is it can provide default `webpack.config.js` and `tsconfg.json`,\nand with `--code` option we can edit ts files with vscode super easily.\n\n","h,help p,print-dir fast rebuild watch root x,debug c,code f,force clean rm keep-link install mode: template:",{argv:t,stopAtFirstArg:!0}),{debug:u,force:h,clean:g,rm:w,root:b,"print-dir":x,install:v,"keep-link":y,mode:O}=c;let $=c?.code;const[k,...j]=o,_=(0,i.tmpdir)(),E=n.join(_,"nx-sync");if(b)return void console.log(E);if(!k)throw new Error("requires script to run");if("update"===k)return void await(0,a.run)("npm remove -g node-ext; npm install -g node-ext",{debug:u});if("create"===k)return void await async function(e){const t=e?.file;if("list"===e.template){const e=Object.keys(d.files).map((e=>(e.endsWith(".ts")&&(e=e.slice(0,e.length-".ts".length)),e)));return void console.log(e.join("\n"))}if(t)if(e?.force)await r.mkdir(n.dirname(t),{recursive:!0});else{let e=!0;if(await r.stat(t).catch((()=>{e=!1})),e)throw new Error(`file already exists: ${t}`)}let o=e.template;o||(o="cmd.ts");const i=d.files[o]||d.files[o+".ts"];if(!i)throw new Error(`template ${o} does not exist`);t?(await r.writeFile(t,i,{encoding:"utf-8"}),await(0,a.run)(`nx --code ${t}`)):console.log(i)}({template:c?.template,file:j?.[0],force:c?.force});let S=n.resolve(k);if(!n.isAbsolute(S))throw new Error(`failed to make ${k} absolute, the resolved path is ${S}`);y||(S=await r.realpath(S));const M=await r.stat(S).catch((e=>{throw new Error(`not exists: ${k}`)}));let P=!1,F=S,T=S;if(M.isDirectory())$=!0,P=!0;else{if(!M.isFile())throw new Error(`not a file: ${k}`);T=n.dirname(S),F=n.join(T,p(n.basename(S)))}if(!n.isAbsolute(F))throw new Error(`failed to detect absolute dir of ${k}, the resolved dir is ${F}`);if(F===E||F.startsWith(E))throw new Error(`${k} resides in nx-sync dir: ${E}, try another location`);const A=n.join(E,F);let N,C;if(u&&console.error("target dir:",A),!c?.fast){const[e,t]=await Promise.all([P?null:f(S),(0,a.runOutput)("npm -g root")]),o={};Object.keys(e?.installMap||{}).forEach((e=>{o[e]=`./node_modules/${e}`}));const i={...m(e?.importMap,t),...o,"@":"./","@node-ext":n.resolve(t,"node-ext/lib")};if((g||w)&&(await r.rm(A,{recursive:!0}),w))return;await r.mkdir(A,{recursive:!0});const c=(0,s.formatPackageJSON)({name:"tmp",installMap:e?.installMap}),d=(0,s.formatTsConfigJSON)({importMap:i}),p=(0,s.formatWebpackConfigJS)({importMap:i}),b="package.json.checksum";N=h?"":await r.readFile(n.join(A,b),{encoding:"utf-8"}).catch((e=>"")),C=(0,l.createHash)("md5").update(c).digest("hex");const x={"package.json":c,[b]:C,"tsconfig.json":d,"webpack.config.js":p};P||(x["run.ts"]=`import "${S}"`),await Promise.all([...Object.keys(x).map((e=>r.writeFile(n.join(A,e),x[e]))),(0,a.run)(`ln -sf "${T}" "${A}/src"`,{debug:u})])}if(x)return void console.log(A);if($){const e=P?"":`--goto "${A}/src/${n.basename(S)}"`;return void await(0,a.run)(`code ${e} "${A}"`,{debug:u})}if(v)return void await(0,a.run)("npm install --no-audit --no-fund",{debug:u,cwd:A});let W=!1;if(!c?.fast&&(W=h||""===N||c?.rebuild||N!==C,!W)){let e=!1;await r.stat(n.join(A,"node_modules")).then((n=>e=n.isDirectory())).catch((e=>{})),W=!e}let J=u?"":"&>/dev/null",D=!c?.fast||h||c?.rebuild,q=!(c?.rebuild||c?.watch),R="build",I="";c?.watch?R="production"===O?"watch":"watch-dev":(R="production"===O?"build":"build-dev",c?.rebuild||c?.debug||(I="&>/dev/null"));const L=`npm run ${R}`;await(0,a.run)(`\n    set -e\n    (\n        cd "$TARGET_DIR"\n        ${W?"npm install --no-audit --no-fund "+J:""}  # npm install is slow so we need a checksum to avoid repeat\n        ${D?`${L} ${I} ;`:""} # dev mode webpack can use build cache\n    )\n    ${q?' node "$TARGET_DIR/bin/run.js" "$@"':""}\n    `,{debug:u,args:j,env:{TARGET_DIR:A},pipeStdin:!0}).catch((e=>{u&&console.error(e?.message||e),process.exit(1)}))}function p(e){return e.replaceAll(/[,?\/\n ()\\+&*^$#@!\\\.]/g,"_")}async function f(e){const n=(i=await r.readFile(e,{encoding:"utf-8"}),(0,c.iterLines)(i,((e,n)=>{const t=i.slice(e,n);if(t.startsWith(h))return t.slice(h.length).trim()})).filter((e=>e))),t={},o={};var i;return n?.forEach?.((e=>{if(e.startsWith("#"))return;let[n,r]=(0,c.trimPrefix)(e,"use ");if(r){let[o,r]=n.split(" ",2);if(o=o.trim(),r=r.trim(),!o||!r)throw new Error(`invalid ${e}: requires name or dir`);t[o]=r}else[n,r]=(0,c.trimPrefix)(e,"install "),r&&n.split(" ").map((e=>e.trim())).map((e=>e.split("@",2))).filter((e=>e[0])).forEach((e=>o[e[0]]=e[1]||"latest"))})),{importMap:t,installMap:o}}function m(e,t){const o={};return Object.keys(e||{}).forEach((r=>{let i=e[r],[s,a]=(0,c.trimPrefix)(i,"$NPM_ROOT/");if(a)i=n.join(t,s);else{let[e,t]=(0,c.trimPrefix)(i,"~/");t&&(i=n.join(process.env.HOME,e))}o[r]=i})),o}e.run=u,e.toDirName=p;const h="//!node-ext:";u().catch((e=>{console.error(e.message),process.exit(1)})).finally((()=>{}))})(),o})()));